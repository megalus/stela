{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-stela","title":"Welcome to Stela","text":"<p>Stela were the \"information files\" of ancient times. This library aims to simplify your project configurations, proposing an opinionated way to manage your project using dotenv files, or using any source you need.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Working with environment variables vs project settings and secrets can be hard.</p> <ul> <li>Sometimes we need to define a default value for a secret, like a database url, to run unit tests.</li> <li>Sometimes, we need to set different values for a setting, like an API url, for different environments.</li> <li>Sometimes, we use dotenv on local development, but need to use other services, like vaults or secret managers, to retrieve these same settings and secrets on production.</li> </ul> <p>This library was created to help simplify this process, by providing a single interface to access all data from multiple dotenv files, or if you need, from your custom logic to retrieve your project settings and secrets from another source.</p> <p>About settings and secrets</p> <p>In this documentation we talk a lot about these two concepts. What we meant:</p> <ul> <li><code>settings</code>: Any nonsensible value, which can be different between different environments. This data can be safety committed in your project. Example: API urls, Timeout values, etc..</li> <li><code>secrets</code>: Any sensible value, which you can't commit in you project. Examples: Tokens, Passwords, etc..</li> </ul>"},{"location":"#why-another-library","title":"Why another library?","text":"<p>There are a lot of good libraries to work with project settings:</p> <ul> <li>python-dotenv - One of the most popular. In fact, we use it under the   hood to load the dotenv files.</li> <li>python-decouple - Another good one, this library together with   Dynaconf and Plaster were the main   inspirations for this project until version 5.x</li> <li>Pydantic - A very powerful solution for data validation, they provide a   Settings Management tool, which is an good solution for that environment.</li> </ul>"},{"location":"#why-use-stela","title":"Why use Stela?","text":"<p>Our key features:</p> <ol> <li>Learn once, use everywhere. Stela aims to be easily used in any Python project or Framework.</li> <li>Separate settings from secrets from environments. Instead of using a single dotenv file to store all your settings,    we use multiple dotenv files, one for each environment. This way, you can split secrets from settings, and you can    have different values for the same environment variable in different environments.</li> <li>Easy to implement. Use the command <code>stela init</code> to initialize your project and configure <code>.env</code> and <code>.gitignore</code>    files.</li> <li>Easy to use. To access you configuration just include <code>from stela import env</code> in your code. Simple as that.</li> <li>One Interface, Any Source. You're not limited to dotenv files. Create your custom logic to import data from any source you need.</li> </ol>"},{"location":"#install","title":"Install","text":"<pre><code>pip install stela\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.10, 3.11 and 3.12</li> </ul>"},{"location":"autocomplete/","title":"Autocomplete data on IDEs","text":"<p>The best way to work with Environment Variables is using the autocomplete (or IntelliSense) feature from your IDE. To make this work with dotenv read data, Stela updates his stub file (<code>stela.__init__.pyi</code>) every time you change your dotenv files.</p> <p></p> <p>This stub file needs to be saved on the same folder which you've installed the <code>stela</code> package (normally via package manager). In other words, in a folder outside your project. To this work, please make sure the user which starts your project has sufficient privileges to access these external folders.</p> <p>It works for dynamic variables too</p> <p>The same is true for values retrieved from other sources than dotenv files (see next section \"The Stela Loader\" ). The stub file is always updated after Stela process the loader.</p>"},{"location":"autocomplete/#troubleshooting-stub-creation","title":"Troubleshooting stub creation","text":"<p>You can enable Stela logs (<code>show_logs</code>) to see the messages regarding stub creation.</p> .stelapyproject.tomlshell <pre><code>[stela]\nshow_logs = true\n</code></pre> <pre><code>[tool.stela]\nshow_logs = true\n</code></pre> <pre><code>$ export STELA_SHOW_LOGS=true\n</code></pre> <p>If you want to manually update the stub file, please use the command <code>stela gen-stub</code></p> <pre><code>$ stela gen-stub\n</code></pre> If I cannot generate the stub? <p>Stela stills works normally, but IDE can't autocomplete the <code>env</code> object with the data received.</p> <p>For the next step, we will look at Stela default loader and how to use another source than dotenv files.</p>"},{"location":"commit/","title":"Committing your settings","text":"<p>Stela is better suited for new projects. This is because, traditionally, the <code>.env</code> file is not committed on python projects. So, you need special attention when porting an existing project to Stela.</p>"},{"location":"commit/#changes-on-gitignore","title":"Changes on .gitignore","text":"<p>By default, Stela will add your <code>.env.local</code> and <code>.env.*.local</code> files to project's <code>.gitignore</code> and will comment the <code>.env</code> entry if exists. This is because you shouldn't commit your secret values, even if you want to use them in your local machine. But some values in this file aren't secrets, and you may want to commit these values. That's why you combine both <code>.env</code> and <code>.env.local</code> files.</p> <p>For example, you may want to commit the <code>API_URL</code> and a fake value, but not the real one for the <code>API_TOKEN</code>:</p> <pre><code># .env - can be committed\n# the value for API_TOKEN here can be used in your CI/CD\n# for running tests, for example\nAPI_URL=https://foo.bar\nAPI_TOKEN=foo\n</code></pre> <pre><code># .env.local - Do not commit! The value for API_TOKEN here is as secret!\n# You don't need to repeat the API_URL here, because\n# it will be loaded from .env file\nAPI_TOKEN=real_token\n</code></pre> <p>The standard python <code>.gitignore</code> need to be updated to reflect this:</p> <pre><code># .gitignore\n\n# .env  # Comment or remove this line\n.env.local  # Add this\n.env.*.local  # Add this\n</code></pre> <p>Use the <code>stela init</code> command</p> <p>The command <code>stela init</code> will make these changes for you on an existing <code>.gitignore</code> file. If you don't have a <code>.gitignore</code> file, the command will create one for you. And if you have a existing <code>.env</code> file in your project, Stela will automatically rename this file to <code>.env.local</code></p> <p>Be careful with the original .env file</p> <p>If you already use a <code>.env</code> file in your project, chances are high this file contains secrets. Please, make sure you rename this file to <code>.env.local</code> (manually or using <code>stela init</code>) or split his contents between these two files (the <code>.env</code> for settings and <code>.env.local</code> for secrets).</p>"},{"location":"commit/#im-not-comfortable-changing-these-settings-can-i-use-stela","title":"I'm not comfortable changing these settings. Can I use Stela?","text":"<p>Sure, just don't run the <code>stela init</code> file and create manually the <code>.stela</code> file, renaming the dotenv file to be used (we suggest: <code>.environs</code>), like this:</p> <pre><code># A very conservative configuration.\n[stela]\nenvironment_variable_name = STELA_ENV\nevaluate_data = False\nshow_logs = False\nenv_file = .environs\nconfig_file_path = .\n</code></pre> <p>In your <code>.gitignore</code> just add:</p> <pre><code>.environs.local\n.environs.*.local\n</code></pre> <p>Stela will read the original <code>.env</code> file, and will overwrite the values using the <code>.environs</code> files.</p> <p>In the next step, we will look closely on how to use Stela in your code.</p>"},{"location":"dotenv/","title":"Using dotenv files","text":"<p>Stela uses dotenv to load additional environment variables from the following files:</p> <pre><code>.env                        # loaded in all cases\n.env.local                  # loaded in all cases, ignored by git\n.env.[environment]          # only loaded in specified environment\n.env.[environment].local    # only loaded in specified environment, ignored by git\n</code></pre> <p>Using default settings, Stela will use the value from <code>STELA_ENV</code> to determine the current environment and will look for dotenv files at the root of the project. You can change this behavior using the <code>environment_variable_name</code> and <code>config_file_path</code> options as described before.</p> <p>The goal here is: Familiarity</p> <p>If you are a frontend developer, probably you already see this naming convention in some node projects, especially Vite. This is intended: learn once to manipulate <code>dotenvs</code>, and use it in all your backend and frontend projects.</p>"},{"location":"dotenv/#a-generic-example","title":"A generic example","text":"<pre><code># .env\nAPI_URL=\"http://localhost:8000\"\nAPI_TOKEN=\"mock_token\"\n</code></pre> <pre><code># .env.local\nAPI_TOKEN=\"local_token\"\n</code></pre> <pre><code># env.development\nAPI_URL=\"https://develop.api.com\"\nAPI_TOKEN=\"development_token\"\n</code></pre> <pre><code># env.development.local\nAPI_TOKEN=\"local_development_token\"\n</code></pre> <p>In the following example, the value for each environment will be:</p> Environment API_URL API_TOKEN Global http://localhost:8000 <code>mock_token</code> Global (local) http://localhost:8000 <code>local_token</code> development https://develop.api.com <code>development_token</code> development (local) https://develop.api.com <code>local_development_token</code>"},{"location":"dotenv/#dotenv-load-priorities","title":"Dotenv Load Priorities","text":"<p>Stela will return the variable value using this priority order:</p> <ol> <li>The value from the system environment, if it did not exist in dotenv file. Ex.: <code>MY_VAR=1 python my_script.py</code></li> <li>The value from the <code>.env.[environment].local</code> if it exists and Stela can find the current environment.</li> <li>The value from the <code>.env.[environment]</code> if it exists and Stela can find the current environment.</li> <li>The value from the <code>.env.local</code> if it exists.</li> <li>The value from the <code>.env</code> if it exists.</li> <li>Will raise a <code>StelaValueError</code>.</li> </ol> <p>Stela will always raise a <code>StelaValueError</code> if you ask for a variable that does not exist in any of the dotenv files or  in memory. You can change this behavior using the <code>raise_on_missing_variable</code> options as described before.</p> <p>Also, Stela will always overwrite the <code>os.environ</code> values with the values from the dotenv files.</p>"},{"location":"dotenv/#a-more-concrete-example","title":"A more concrete Example","text":"<p>Let's create a more complex example, using Django. In this example we will want to run unit tests using the local settings, but run the local server using the remote settings, for debugging purposes.</p> <p>After running <code>stela init</code> add these variables on the created dotenv files:</p> <pre><code># .env\nAPI_URL=\"http://localhost:8000\"\nAPI_TOKEN=\"fake_token\"\nDB_USER=\"foo\"\nDB_PASSWORD=\"bar\"\nDB_HOST=\"localhost\"\nDB_PORT=5432\nDB_NAME=\"test_db\"\nDEBUG=False\n</code></pre> <pre><code># env.local\nDEBUG=True\nDB_PORT=5433\n</code></pre> <p>And add two more dotenv files:</p> <pre><code># env.remote\nAPI_URL=\"https://remote.api.com\"\n</code></pre> <pre><code># env.remote.local\nAPI_TOKEN=\"real_token\"\nDB_USER=\"real_user\"\nDB_PASSWORD=\"real_password\"\nDB_HOST=\"real_host\"\nDB_PORT=5432\nDB_NAME=\"real_name\"\nDEBUG=True\n</code></pre> <p>And finally, let's change the default environment name:</p> .stelapyproject.tomlshell <pre><code>[stela]\nenvironment_variable_name = MY_PROJECT_ENV  # change here\n...\n</code></pre> <pre><code>[tool.stela]\nenvironment_variable_name = MY_PROJECT_ENV  # change here\n...\n</code></pre> <pre><code>$ export STELA_ENVIRONMENT_VARIABLE_NAME=MY_PROJECT_ENV\n</code></pre> <p>Let's run unit tests using the local settings:</p> <pre><code># Running django tests locally using default settings\n$ python manage.py test\n</code></pre> <pre><code># settings.py\nfrom stela import env\n\nENV = env.current_environment  # \"GLOBAL\" because no environment was declared\nDEBUG = env.DEBUG  # True from .env.local\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': env.DB_NAME,  # \"test_db\" from .env\n        'USER': env.DB_USER,  # \"foo\" from .env\n        'PASSWORD': env.DB_PASSWORD,  # \"bar\" from .env\n        'HOST': env.DB_HOST,  # \"localhost\" from .env\n        'PORT': env.DB_PORT,  # 5433 from .env.local\n    }\n}\nAPI_URL = env.API_URL  # \"http://localhost:8000\" from .env\nAPI_TOKEN = env.API_TOKEN  # \"fake_token\" from .env\n</code></pre> <p>Running again the server using the remote settings:</p> <pre><code># Running django tests locally using remote settings\n$ MY_PROJECT_ENV=remote python manage.py runserver\n</code></pre> <pre><code># settings.py\nfrom stela import env\n\nENV = env.current_environment  # \"remote\" from MY_PROJECT_ENV in memory\nDEBUG = env.DEBUG  # True from .env.remote.local\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': env.DB_NAME,  # \"real_name\" from .env.remote.local\n        'USER': env.DB_USER,  # \"real_user\" from .env.remote.local\n        'PASSWORD': env.DB_PASSWORD,  # \"real_password\" from .env.remote.local\n        'HOST': env.DB_HOST,  # \"real_host\" from .env.remote.local\n        'PORT': env.DB_PORT,  # 5432 from .env.remote.local\n    }\n}\nAPI_URL = env.API_URL  # \"https://remote.api.com\" from .env.remote\nAPI_TOKEN = env.API_TOKEN  # \"real_token\" from .env.remote.local\n</code></pre> <p>In the next step, we will understand how to commit these new settings.</p>"},{"location":"frameworks/","title":"Using Frameworks","text":"<p>Stela runs at the module level, when you use the <code>from stela import env</code> import. Because that, it will work seamlessly with many python packages and frameworks. Below are the recommendations and best practices for many of them:</p> <p>Please check the folder: /examples</p> <p>It contains working implementations for many frameworks.</p>"},{"location":"frameworks/#popular-framework-examples","title":"Popular Framework Examples","text":""},{"location":"frameworks/#django","title":"Django","text":"<p>The best practice for Django projects is to consume the Stela <code>env</code> object on django <code>settings.py</code> module. This is because many django packages look at this file to consume and define his own settings.</p> <pre><code># Django settings.py\nfrom stela import env\n\nDEBUG = env.DEBUG\n</code></pre>"},{"location":"frameworks/#pydantic-2x","title":"Pydantic 2.x","text":"<p>Pydantic uses the BaseSettings logic to handle environment variables. If you want to use Pydantic Settings with Stela dotenv file combinations (<code>.env</code>, <code>.env.local</code>, etc..) you can use:</p> <p><pre><code># .env.local\nFOO__BAR=123\n</code></pre> Use class <code>StelaConfigSettingsSource</code> to replace the original <code>env_settings</code> in your Settings class:</p> <pre><code>from typing import Tuple, Type\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n)\nfrom stela.helpers.pydantic import StelaConfigSettingsSource\n\n\nclass FooSettings(BaseSettings):\n    bar: str\n\n\nclass Settings(BaseSettings):\n\n    model_config = SettingsConfigDict(extra=\"ignore\", env_nested_delimiter=\"__\", log_stela_settings=True)\n\n    foo: FooSettings\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: Type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; Tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            init_settings,\n            StelaConfigSettingsSource(settings_cls),\n            file_secret_settings,\n        )\n\n\nprint(Settings().foo.bar)\n#&gt; 123\n</code></pre>"},{"location":"frameworks/#fastapi","title":"FastAPI","text":"<p>You can use FastAPI with Stela directly ou via Pydantic Settings (if you use the settings above).</p>"},{"location":"frameworks/#aws-chalice","title":"AWS Chalice","text":"<p>We currently don't support Chalice <code>autoreload</code> in local server. To work around this please use the command <code>chalice local --no-autoreload</code> or import <code>env</code> inside a function.</p>"},{"location":"frameworks/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>The recommended practice is to import Stela data at the first cell, using the <code>%set_env</code> variables to define Stela behavior and then call <code>read_env</code> function to retrieve the Environment Variables:</p> <pre><code># %%\nfrom stela.utils import read_env\n\n### You can change Stela behavior here\n%set_env STELA_ENV = remote\n%set_env STELA_SHOW_LOGS = False\n\n### And use the `read_env` helper to reload environment variables\nenv = read_env()\n\nprint(f\"Current Environment: {env.current_environment}\")\nprint(f\"My Secret: {env.MY_SECRET}\")\n# %%\n</code></pre> <p>For the next step, let's review all Stela options</p>"},{"location":"initialization/","title":"Initializing Stela","text":"<p>For new projects we recommend running the command <code>stela init</code> to create your project settings configuration.</p> <pre><code>stela init\n</code></pre> <p>This command will prompt for the following configurations:</p>"},{"location":"initialization/#environment-variable-name-environment_variable_name","title":"Environment variable name (<code>environment_variable_name</code>)","text":"<p>This is the name of the environment variable that Stela will use to find the current environment. By default, is <code>STELA_ENV</code> but you can change it to whatever you want, like ENV, DJANGO_ENV, etc...</p>"},{"location":"initialization/#default-environment-default_environment","title":"Default environment (<code>default_environment</code>)","text":"<p>If you define a Environment variable name, but not the value for it, Stela can use this optional default environment value. By default, this is disabled and his default value, if enabled, is <code>development</code>.</p>"},{"location":"initialization/#evaluate-dotenv-values-evaluate_data","title":"Evaluate dotenv values (<code>evaluate_data</code>)","text":"<p>If you want to evaluate the values in your dotenv files, you can enable this option. By default, every value from dotenv files are treated as string. If you enable this option, Stela will try to evaluate the values as per ast.literal_eval rules. If the value can't be evaluated, you still receive the string value.</p>"},{"location":"initialization/#show-stela-info-in-logs-show_logs","title":"Show Stela info in logs (<code>show_logs</code>)","text":"<p>If you want to see Stela info in your logs, you can enable this option. By default, this is disabled. Also, if you enable logs, you can filter the values displayed (the default value for this sub-option is enabled) (<code>log_filtered_value</code>).</p>"},{"location":"initialization/#dotenv-file-name-env_file","title":"Dotenv file name (<code>env_file</code>)","text":"<p>If you want to use a different name for your dotenv files, you can change it here. By default, this is <code>.env</code>.</p>"},{"location":"initialization/#stela-project-files","title":"Stela Project Files","text":"<p>Using the information provided, Stela will save their configuration in the <code>.stela</code> file.</p> <p>Tip: You can use your <code>pyproject.toml</code> too.</p> <p>If you use this file, the command will ask if you want to save stela configuration inside toml file.</p> <p>After that, Stela will create the following files if they don't exist:</p> <ul> <li><code>.env</code> (or the name you defined in the previous step)</li> <li><code>.env.local</code></li> <li><code>.env.[environment]</code> (or the name you defined in the previous step if you enabled default environment)</li> <li><code>.env.[environment].local</code></li> <li><code>.gitignore</code></li> </ul>"},{"location":"initialization/#configuration-file-example","title":"Configuration file example:","text":"<p>Using default settings</p> .stelapyproject.tomlshell <pre><code>[stela]\nenvironment_variable_name = STELA_ENV\nevaluate_data = True\nshow_logs = False\nenv_file = .env\nconfig_file_path = .\n</code></pre> <pre><code>[tool.stela]\nenvironment_variable_name = \"STELA_ENV\"\nevaluate_data = true\nshow_logs = false\nenv_file = \".env\"\nconfig_file_path = \".\"\n</code></pre> <pre><code>$ export STELA_ENVIRONMENT_VARIABLE_NAME=\"STELA_ENV\"\n$ export STELA_EVALUATE_DATA=true\n$ export STELA_SHOW_LOGS=false\n$ export STELA_ENV_FILE=\".env\"\n$ export STELA_CONFIG_FILE_PATH=\".\"\n</code></pre> <p>See section Settings for the complete Stela options list.</p> <p>In the next step, we will deep dive how Stela uses dotenv files.</p>"},{"location":"quick_setup/","title":"Quick Setup","text":"<p>Let's start with a quick setup: suppose a project add with a <code>.env</code> file with the following content:</p> <pre><code># .env\nAPI_URL=\"http://localhost:8000\"\nDB_URL=\"db://fake_user:fake_password@local_db:0000/name\"\n</code></pre> <p>Import the <code>env</code> object from <code>stela</code> and use it:</p> <pre><code># settings.py\nfrom stela import env\n\nAPI_URL = env.API_URL  # http://localhost:8000\nDATABASE_URL_CONNECTION = env.DB_URL  # db://fake_user:fake_password@local_db:0000/name\n</code></pre> <p>Now, create a <code>.env.local</code> file and add the secret value:</p> <pre><code># .env.local\nDB_URL=\"db://real_user:real_password@real_db:0000/name\"\n</code></pre> <pre><code># settings.py\nfrom stela import env\n\nAPI_URL = env.API_URL  # http://localhost:8000\nDATABASE_URL_CONNECTION = env.DB_URL  # db://real_user:real_password@real_db:0000/name\n</code></pre> <p>This is because Stela will first load the content from <code>.env</code> file, and then will override the values with the content from <code>.env.local</code> file.</p>"},{"location":"quick_setup/#but-how-about-the-environments","title":"But how about the environments?","text":"<p>Ok, lets add another file: <code>.env.remote</code>:</p> <pre><code># .env.remote\nAPI_URL=\"https://remote.api.com\"\n</code></pre> <p>And we export the <code>STELA_ENV</code> variable:</p> <pre><code>export STELA_ENV=remote\n</code></pre> <p>When we run the python code, we will get the following values:</p> <pre><code>from stela import env\n\nAPI_URL = env.API_URL  # https://remote.api.com\nDATABASE_URL_CONNECTION = env.DB_URL  # db://real_user:real_password@real_db:0000/name\n</code></pre> <p>What's happened here?</p> <ol> <li>Stela will load the content from <code>.env</code> file.</li> <li>Then, it will load the content from <code>.env.local</code> file, overriding previous content, because Stela always looks for <code>.env.*.local</code> files</li> <li>Finally, it will load the content from <code>.env.remote</code> file, overriding previous content, because STELA_ENV is set to <code>remote</code>.</li> </ol> <p>And that's it! Now you can use Stela to manage your settings in any python project.</p> <p>Stela is highly customizable, so you can use it in any way you want. It can handle several use cases you can have handling your project settings.</p> <p>For the next pages, let's see each one of these options with more details.</p>"},{"location":"settings/","title":"All Stela Settings options","text":"<p>You can define any of these options as an environment variable, using the <code>STELA_</code> prefix. Some examples:</p> <pre><code>$ export STELA_SHOW_LOGS=true\n$ export STELA_FINAL_LOADER=\"foo.bar\"\n</code></pre> Stela Option Description <code>config_file_path</code> Relative path for dotenv files. Default: <code>.</code> <code>default_environment</code> Default environment value, used if <code>environment_variable_name</code> if not informed. Default: <code>None</code> <code>dotenv_encoding</code> Use this encoding to read dotenv files. Default: <code>utf-8</code> <code>env_file</code> Stela \"env\" file name. Default: <code>.env</code> <code>env_table</code> The table or section to read data in custom files (toml, ini, etc...). Default: <code>env</code> <code>environment_variable_name</code> Stela environment variable to define project current environment. Default: <code>STELA_ENV</code> <code>evaluate_data</code> Use <code>ast.literal_eval</code> to evaluate variable values. Default: <code>True</code> <code>final_loader</code> Stela Loader function which will be called after read dotenv files. Default: <code>stela.main.loader.default_loader</code> <code>log_filtered_value</code> When logging data, show values filtered. Default: <code>True</code> <code>raise_on_missing_variable</code> Raise error if ask Stela for a unknown variable. Default: <code>True</code> <code>show_logs</code> Stela will use loguru to show logs. Default: <code>False</code> <code>warn_if_env_is_missing</code> Warn if Stela did not find the <code>.env</code> file. Default: <code>False</code> <p>All these options are available in code</p> <p>When you create a custom loader, all options above are available in the <code>options</code> object: <pre><code>def my_custom_loader(options: StelaOptions, env_data: dict) -&gt; dict:\n    dotenv_encoding = options.dotenv_encoding\n</code></pre></p>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>django-google-sso: Add Google Authentication in your Django projects with ease.</li> <li>django-microsoft-sso: Add Microsoft 365 Authentication in your Django projects with ease.</li> <li>django-github-sso: Add GitHub Authentication in your Django projects with ease.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"the_final_loader/","title":"The final loader","text":""},{"location":"the_final_loader/#the-stela-final-loader","title":"The Stela Final Loader","text":"<p>Stela always loads the data from the dotenv files, we call it the First Loader.</p> <p>After that, Stela calls the Final Loader function, which just return the data received from the First Loader.</p> <p>You can configure Stela to use your own Final Loader function, or use the default one.</p> <p>Stela Final Loader is a function that receives two arguments:</p> <ul> <li>The Stela Options object: <code>options</code></li> <li>The dictionary content the data from dotenvs read based on current stela options: <code>env_data</code></li> </ul> <p>And it's the last code called for before returning the <code>env</code> object.</p>"},{"location":"the_final_loader/#default-stela-final-loader-code","title":"Default Stela Final Loader code","text":"<p>Default behavior is just return data parsed from Env files:</p> <pre><code>from stela.config import StelaOptions\n\n\ndef default_loader(\n        options: StelaOptions,\n        env_data: dict[str, any]\n) -&gt; dict[str, any]:\n    \"\"\"Stela Default Loader.\n\n    Default Action is just return the env_data received.\n\n    :param options: Stela Options\n    :param env_data: Dict with environment data\n    :return: Dict\n    \"\"\"\n    from loguru import logger\n\n    logger.info(\n        f\"Using Stela Default Loader. \"\n        f\"Current environment is: {options.current_environment}\"\n    )\n    return env_data\n</code></pre>"},{"location":"the_final_loader/#the-stela-options-object","title":"The Stela Options object","text":"<p>All stela options are attributes in this object. Please check Settings for the complete list.</p>"},{"location":"the_final_loader/#creating-your-custom-final-loader","title":"Creating your custom Final Loader","text":"<p>If you need to get your Environment variables from other sources than dotenv files, or need to mix data, you can use your own logic for the Loader. Just inform Stela which function needs to be called:</p> .stelapyproject.tomlshell <pre><code>[stela]\nfinal_loader = \"path.to.my.custom_loader\"\n...\n</code></pre> <pre><code>[tool.stela]\nfinal_loader=\"path.to.my.custom_loader\"\n...\n</code></pre> <pre><code>$ export STELA_FINAL_LOADER=\"path.to.my.custom_loader\"\n</code></pre> <p>This function will be called, and need to receive the two parameters above: <code>options</code> and <code>env_data</code> and it must return a valid python dictionary.</p>"},{"location":"the_final_loader/#examples","title":"Examples","text":""},{"location":"the_final_loader/#read-data-from-toml-file","title":"Read data from toml file","text":"<pre><code>import toml\nfrom typing import Any\nfrom stela.config import StelaOptions\nfrom stela.utils import merge_env\n\n\ndef pyproject_loader(options: StelaOptions, env_data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Load settings from pyproject.toml to current Stela data.\n\n    Data returned must be a Python Dictionary.\n\n    :param env_data: Data parsed from dotenv files\n    :param options: Stela Options obj\n    :return Dict[str, Any]\n    \"\"\"\n    filepath = \"pyproject.toml\"\n    sub_table = \"environment\"  # The sub table inside toml which holds your settings\n\n    # Read toml data for the sub table\n    toml_data = toml.load(filepath)\n    sub_table_data = toml_data.get(sub_table, {})\n\n    # Update toml data with dotenv info\n    # The sub_table_data are the \"default\" settings.\n    # The env_data are the final ones.\n    project_settings = merge_env(sub_table_data, env_data)\n\n    return project_settings\n</code></pre>"},{"location":"the_final_loader/#read-data-from-aws-system-manager-parameter-store","title":"Read data from AWS System Manager Parameter Store","text":"<pre><code>import boto3\nfrom typing import Any\nfrom stela.config import StelaOptions\n\n\ndef ssm_loader(options: StelaOptions, env_data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Load settings from AWS Parameter Store (SSM) to current Stela data.\n\n    Data returned must be a Python Dictionary.\n\n    :param env_data: Data parsed from dotenv file\n    :param options: Stela Options obj\n    :return Dict[str, Any]\n    \"\"\"\n    ssm = boto3.client('ssm')\n    environment = options.current_environment\n\n    # Get from SSM\n    response = ssm.get_parameters_by_path(\n        Path=f'/my-project/{environment}',\n        WithDecryption=True\n    )\n    ssm_data = {parameter[\"Name\"].upper(): parameter[\"Value\"] for parameter in response[\"Parameters\"]}\n\n    # Overwrite env_data with SSM data\n    # Normally information on remote sources\n    # like vaults, are the final ones\n    env_data.update(ssm_data)\n\n    return env_data\n</code></pre> <p>The goal here is: One Interface, Any Sources</p> <p>You can use any source or logic to load your environment variables. They can have the complexity you need for the project you're working. But the interface to work with these values is always the same.</p>"},{"location":"the_final_loader/#different-loaders-per-environment","title":"Different Loaders per Environment","text":"<p>If you need different custom loaders per environment, you can use Stela Environment variables to do this:</p> <pre><code># Development\n$ export STELA_FINAL_LOADER=\"path.to.dev_loader\"\n</code></pre> <pre><code># Production\n$ export STELA_FINAL_LOADER=\"path.to.prod_loader\"\n</code></pre> <p>For the next step, let's review how to integrate Stela with many popular Python packages and Frameworks.</p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-questions","title":"Common questions:","text":"How can I use [...] with Stela? <p>The use cases in Using Frameworks above give a good hint about how to use Stela with several python projects. If you have a question which this guideline didn't resolve, please open an issue.</p> Got Error: Stela did not found value for , but MY_VARIABLE exists in .env file. <p>Please check if the root project folder is the same as the stela configuration file. If is correct, and your .env file is in another folder, you can use the <code>env_path</code> parameter to set the path to the .env file. You can also turn on Stela logs (<code>export STELA_SHOW_LOGS=true</code>) to see if the .env file and stela configuration file are being loaded correctly.</p> Stela is not importing on my asynchronous code. <p>Stela was tested against many popular asynchronous libraries like Django-Ninja, Starlite and Sanic, and almost all the time the <code>from stela import env</code> import works successfully.</p> <p>But there's some cases, especially when using blocking final loaders, that the <code>from stela import env</code> import will not work, or will give a blocking error. In these cases, you can use the <code>aread_env</code> function to read the environment variables. This function is a coroutine, so you need to use the <code>await</code> keyword to call it.</p> <pre><code>from my_project import app\nfrom stela.asyncio import aread_env\n\n\n@app.get(\"/\")\nasync def root():\n    env = await aread_env()\n    return {\n        \"message\": \"Hello World\",\n        \"environment\": env.current_environment,\n        \"secret\": env.MY_SECRET,\n    }\n</code></pre>"},{"location":"troubleshooting/#example-apps","title":"Example Apps","text":"<p>To see how this library works check the <code>Example Folder</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"usage/","title":"Using Stela","text":"<p>Stela usage is very simple. Just import the <code>env</code> object:</p> <pre><code>from stela import env\n\nMY_VAR = env.MY_VAR\n</code></pre> <p>If you want to get the environment variable programmatically, use the <code>get</code> function:</p> <pre><code>from stela import env\n\nvar = \"MY_VAR\"\nvalue = env.get(var)\n</code></pre> <p>If the variable did not exist, Stela will raise a <code>StelaValueError</code>. You can change this using the <code>raise_on_missing</code> parameter:</p> <pre><code>from stela import env\n\nvar = \"THIS_VAR_DOES_NOT_EXIST\"\nvalue = env.get(var, raise_on_missing=False)\n#&gt; None\n</code></pre> <p>If you want to return a default value if the variable does not exist, use the <code>get_or_default</code> function:</p> <pre><code>from stela import env\n\nvar = \"THIS_VAR_DOES_NOT_EXIST\"\nvalue = env.get_or_default(var, default=\"default_value\")\n#&gt; \"default_value\"\n</code></pre> <p>You can also list all environment variables:</p> <pre><code>from stela import env\n\nall_vars = env.list()\n#&gt; [\"MY_VAR\"]\n</code></pre> <p>And you can use the <code>env</code> object to get information about the current environment:</p> <pre><code>from stela import env\n\nENV = env.current_environment\nDEFAULT_ENV = env.default_environment\n</code></pre>"},{"location":"usage/#when-stela-read-the-data","title":"When Stela read the data?","text":"<p>Stela is imported once at module level - project settings are load and immediately available:</p> <pre><code>from stela import env\nfrom flask import Flask\n\napp = Flask(__name__)\napp.config.update(\n    SECRET_KEY=env.FLASK_SECRET\n)\n\n\n@app.route(\"/\")\ndef hello():\n    return f\"Hello, Environment is {env.current_environment}\"\n</code></pre>"},{"location":"usage/#refreshing-stela-settings","title":"Refreshing Stela settings","text":"<p>If you need to reload settings, use the <code>stela.utils.read_env</code> function:</p> <pre><code>from stela.utils import read_env\n\ndef reload_app():\n    env = read_env()\n</code></pre>"},{"location":"usage/#logging-data","title":"Logging data","text":"<p>Stela use the loguru package for logging, using <code>INFO</code> for general messages and <code>DEBUG</code> for key/values retrieved in toml, environment keys, decorators, etc... You can use the logs to debug data during Stela operation.</p> <p>By default, the log is disabled. You can modify this behavior globally with the following configurations:</p> .stelapyproject.tomlshell <pre><code>[stela]\nshow_logs = true\nlog_filtered_value = true\n</code></pre> <pre><code>[tool.stela]\nshow_logs = true\nlog_filtered_value = true\n</code></pre> <pre><code>$ export STELA_SHOW_LOGS=true\n$ export STELA_LOG_FILTERED_VALUE=true\n</code></pre> <p>Also, you can use decorators for fine-tuning logging per function:</p> <pre><code>from stela import env\nfrom stela.decorators import stela_enable_logs, stela_disable_logs\n\n\n@stela_enable_logs\ndef my_bugged_code():\n    return env.MY_API_URL\n\n\n@stela_disable_logs\ndef my_sensible_code():\n    return env.MY_SECRET_KEY\n</code></pre> <p>The log level can be defined using the <code>LOGURU_LOG_LEVEL</code> as per loguru documentation.</p> <p>For the next step, we will look at how IDEs can autocomplete Stela environment variables.</p>"}]}