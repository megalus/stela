{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-stela","title":"Welcome to Stela","text":"<p>Stela were the \"information files\" of ancient times. This library aims to simplify your project configurations, proposing an opinionated way to manage your project using dotenv files, or using any source you need.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Working with environment variables vs project settings and secrets can be hard.</p> <ul> <li>Sometimes we need to define a default value for a secret, like a database url, to run unit tests.</li> <li>Sometimes, we need to set different values for a setting, like an API url, for different environments.</li> <li>Sometimes, we use dotenv on local development, but need to use other services, like vaults or secret managers, to retrieve these same settings and secrets on production.</li> </ul> <p>This library was created to help simplify this process, by providing a single interface to access all data from multiple dotenv files, or if you need, from your custom logic to retrieve your project settings and secrets from another source.</p> <p>About settings and secrets</p> <p>In this documentation we talk a lot about these two concepts. What we meant:</p> <ul> <li><code>settings</code>: Any nonsensible value, which can be different between different environments. This data can be safety committed in your project. Example: API urls, Timeout values, etc..</li> <li><code>secrets</code>: Any sensible value, which you can't commit in you project. Examples: Tokens, Passwords, etc..</li> </ul>"},{"location":"#why-another-library","title":"Why another library?","text":"<p>There are a lot of good libraries to work with project settings:</p> <ul> <li>python-dotenv - One of the most popular. In fact, we use it under the   hood to load the dotenv files.</li> <li>python-decouple - Another good one, this library together with   Dynaconf and Plaster were the main   inspirations for this project until version 5.x</li> <li>Pydantic - A very powerful solution for data validation, they provide a   Settings Management tool, which is an exceptional solution too.</li> </ul>"},{"location":"#why-use-stela","title":"Why use Stela?","text":"<p>Our key features:</p> <ol> <li>Learn once, use everywhere. Stela aims to be easily used in any Python project or Framework.</li> <li>Separate settings from secrets from environments. Instead of using a single dotenv file to store all your settings,    we use multiple dotenv files, one for each environment. This way, you can split secrets from settings, and you can    have different values for the same environment variable in different environments.</li> <li>Easy to implement. Use the command <code>stela init</code> to initialize your project and configure <code>.env</code> and <code>.gitignore</code>    files.</li> <li>Easy to use. To access you configuration just include <code>from stela import env</code> in your code. Simple as that.</li> <li>One Interface, Any Source. You're not limited to dotenv files. Create your custom logic to import data from any source you need.</li> </ol>"},{"location":"#install","title":"Install","text":"<pre><code>pip install stela\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.9, 3.10 and 3.11</li> </ul>"},{"location":"autocomplete/","title":"Autocomplete data on IDEs","text":"<p>The best way to work with Environment Variables is using the autocomplete (or IntelliSense) feature from your IDE. To make this work with dotenv read data, Stela updates his stub file (<code>stela.__init__.pyi</code>) every time you change your dotenv files.</p> <p></p> <p>This stub file needs to be saved on the same folder which you've installed the <code>stela</code> package (normally via package manager). In other words, in a folder outside your project. To this work, please make sure the user which starts your project has sufficient privileges to access these external folders.</p> <p>It works for dynamic variables too</p> <p>The same is true for values retrieved from other sources than dotenv files (see next section \"The Stela Loader\" ). The stub file is always updated after Stela process the loader.</p>"},{"location":"autocomplete/#troubleshooting-stub-creation","title":"Troubleshooting stub creation","text":"<p>You can enable Stela logs (<code>show_logs</code>) to see the messages regarding stub creation.</p> .stelapyproject.tomlshell <pre><code>[stela]\nshow_logs = true\n</code></pre> <pre><code>[tool.stela]\nshow_logs = true\n</code></pre> <pre><code>$ export STELA_SHOW_LOGS=true\n</code></pre> <p>If you want to manually update the stub file, please use the command <code>stela gen-stub</code></p> <pre><code>$ stela gen-stub\n</code></pre> If I cannot generate the stub? <p>Stela stills works normally, but IDE can't autocomplete the <code>env</code> object with the data received.</p> <p>For the next step, we will look at Stela default loader and how to use another source than dotenv files.</p>"},{"location":"commit/","title":"Committing your settings","text":"<p>Stela is better suited for new projects. This is because, traditionally, the <code>.env</code> file is not committed on python projects. So, you need special attention when porting an existing project to Stela.</p>"},{"location":"commit/#changes-on-gitignore","title":"Changes on .gitignore","text":"<p>By default, Stela will add your <code>.env.local</code> and <code>.env.*.local</code> files to project's <code>.gitignore</code> and will replace the <code>.env</code> entry if exists. This is because you shouldn't commit your secret values, even if you want to use them in your local machine. But, some settings aren't secrets, and you may want commit these values. That's why you combine both <code>.env</code> and <code>.env.local</code> files.</p> <p>For example, you may want to commit the <code>API_URL</code> and a fake value, but not the real one for the <code>API_TOKEN</code>:</p> <pre><code># .env - can be commited\n# the value for API_TOKEN here can be used in your CI/CD\n# for running tests, for example\nAPI_URL=https://foo.bar\nAPI_TOKEN=foo\n</code></pre> <pre><code># .env.local - Do not commit! The value for API_TOKEN here is as secret!\n# You don't need to repeat the API_URL here, because\n# it will be loaded from .env file\nAPI_TOKEN=real_token\n</code></pre> <p>The standard python <code>.gitignore</code> need to be updated to reflect this:</p> <pre><code># .gitignore\n!.env  # Change this line or remove it\n.env.local  # Add this\n.env.*.local  # Add this\n</code></pre> <p>Use the <code>stela init</code> command</p> <p>The command <code>stela init</code> will make these changes for you on an existing <code>.gitignore</code> file. If you don't have a <code>.gitignore</code> file, the command will create one for you. And if you have a existing <code>.env</code> file in your project, Stela will automatically rename this file to <code>.env.local</code></p> <p>Be careful with the original .env file</p> <p>If you already use a <code>.env</code> file in your project, chances are high this file contains secrets. Please, make sure you rename this file to <code>.env.local</code> (manually or using <code>stela init</code>) or split his contents between these two files (the <code>.env</code> for settings and <code>.env.local</code> for secrets).</p>"},{"location":"commit/#im-not-comfortable-changing-these-settings-can-i-use-stela","title":"I'm not comfortable changing these settings. Can I use Stela?","text":"<p>Sure, just don't run the <code>stela init</code> file and create manually the <code>.stela</code> file, renaming the dotenv file to be used (can we suggest: <code>.environs</code>?), like this:</p> <pre><code># A very conservative configuration.\n[stela]\nenvironment_variable_name = STELA_ENV\nevaluate_data = False\nshow_logs = False\ndotenv_overwrites_memory = False\nenv_file = .environs\nconfig_file_path = .\n</code></pre> <p>In your <code>.gitignore</code> just add:</p> <pre><code>.environs.local\n.environs.*.local\n</code></pre> <p>In the next step, we will look closely on how to use Stela in your code.</p>"},{"location":"dotenv/","title":"Using dotenv files","text":"<p>Stela uses dotenv to load additional environment variables from the following files:</p> <pre><code>.env                        # loaded in all cases\n.env.local                  # loaded in all cases, ignored by git\n.env.[environment]          # only loaded in specified environment\n.env.[environment].local    # only loaded in specified environment, ignored by git\n</code></pre> <p>Using default settings, Stela will use the value from <code>STELA_ENV</code> to determine the current environment and will look for dotenv files at the root of the project. You can change this behavior using the <code>environment_variable_name</code> and <code>config_file_path</code> options as described before.</p> <p>The goal here is: Familiarity</p> <p>If you are a frontend developer, probably you already see this naming convention in some node projects, especially Vite. This is intended: learn once to manipulate <code>dotenvs</code>, and use it in all your backend and frontend projects.</p>"},{"location":"dotenv/#a-generic-example","title":"A generic example","text":"<pre><code># .env\nAPI_URL=\"http://localhost:8000\"\nAPI_TOKEN=\"mock_token\"\n</code></pre> <pre><code># .env.local\nAPI_TOKEN=\"local_token\"\n</code></pre> <pre><code># env.development\nAPI_URL=\"https://develop.api.com\"\nAPI_TOKEN=\"development_token\"\n</code></pre> <pre><code># env.development.local\nAPI_TOKEN=\"local_development_token\"\n</code></pre> <p>In the following example, the value for each environment will be:</p> Environment API_URL API_TOKEN Global http://localhost:8000 <code>mock_token</code> Global (local) http://localhost:8000 <code>local_token</code> development https://develop.api.com <code>development_token</code> development (local) https://develop.api.com <code>local_development_token</code>"},{"location":"dotenv/#dotenv-load-priorities","title":"Dotenv Load Priorities","text":"<p>Stela will return the variable value using this priority order:</p> <ol> <li>The value from the system environment, if it exists. Ex.: <code>MY_VAR=1 python my_script.py</code></li> <li>The value from the <code>.env.[environment].local</code> if it exists and Stela can find the current environment.</li> <li>The value from the <code>.env.[environment]</code> if it exists and Stela can find the current environment.</li> <li>The value from the <code>.env.local</code> if it exists.</li> <li>The value from the <code>.env</code> if it exists.</li> <li>Will raise a <code>StelaValueError</code>.</li> </ol> <p>You can change this behavior using the <code>dotenv_overwrites_memory</code> and <code>raise_on_missing_variable</code> options as described before.</p>"},{"location":"dotenv/#a-more-concrete-example","title":"A more concrete Example","text":"<p>Let's create a more complex example, using Django. In this example we will want to run unit tests using the local settings, but run the local server using the remote settings, for debugging purposes.</p> <p>After running <code>stela init</code> add these variables on the created dotenv files:</p> <pre><code># .env\nAPI_URL=\"http://localhost:8000\"\nAPI_TOKEN=\"fake_token\"\nDB_USER=\"foo\"\nDB_PASSWORD=\"bar\"\nDB_HOST=\"localhost\"\nDB_PORT=5432\nDB_NAME=\"test_db\"\nDEBUG=False\n</code></pre> <pre><code># env.local\nDEBUG=True\nDB_PORT=5433\n</code></pre> <p>And add two more dotenv files:</p> <pre><code># env.remote\nAPI_URL=\"https://remote.api.com\"\n</code></pre> <pre><code># env.remote.local\nAPI_TOKEN=\"real_token\"\nDB_USER=\"real_user\"\nDB_PASSWORD=\"real_password\"\nDB_HOST=\"real_host\"\nDB_PORT=5432\nDB_NAME=\"real_name\"\nDEBUG=True\n</code></pre> <p>And finally, let's change the default environment name:</p> .stelapyproject.tomlshell <pre><code>[stela]\nenvironment_variable_name = MY_PROJECT_ENV  # change here\n...\n</code></pre> <pre><code>[tool.stela]\nenvironment_variable_name = MY_PROJECT_ENV  # change here\n...\n</code></pre> <pre><code>$ export STELA_ENVIRONMENT_VARIABLE_NAME=MY_PROJECT_ENV\n</code></pre> <p>Let's run unit tests using the local settings:</p> <pre><code># Running django tests locally using default settings\n$ python manage.py test\n</code></pre> <pre><code># settings.py\nfrom stela import env\nENV = env.current_environment  # \"GLOBAL\" from STELA_ENV default value\nDEBUG = env.DEBUG  # True from .env.local\nDATABASES = {\n'default': {\n'ENGINE': 'django.db.backends.postgresql',\n'NAME': env.DB_NAME,  # \"test_db\" from .env\n'USER': env.DB_USER,  # \"foo\" from .env\n'PASSWORD': env.DB_PASSWORD,  # \"bar\" from .env\n'HOST': env.DB_HOST,  # \"localhost\" from .env\n'PORT': env.DB_PORT,  # 5433 from .env.local\n}\n}\nAPI_URL = env.API_URL  # \"http://localhost:8000\" from .env\nAPI_TOKEN = env.API_TOKEN  # \"fake_token\" from .env\n</code></pre> <p>Running again the server using the remote settings:</p> <pre><code># Running django tests locally using remote settings\n$ MY_PROJECT_ENV=remote python manage.py runserver\n</code></pre> <pre><code># settings.py\nfrom stela import env\nENV = env.current_environment  # \"remote\" from MY_PROJECT_ENV in memory\nDEBUG = env.DEBUG  # True from .env.remote.local\nDATABASES = {\n'default': {\n'ENGINE': 'django.db.backends.postgresql',\n'NAME': env.DB_NAME,  # \"real_name\" from .env.remote.local\n'USER': env.DB_USER,  # \"real_user\" from .env.remote.local\n'PASSWORD': env.DB_PASSWORD,  # \"real_password\" from .env.remote.local\n'HOST': env.DB_HOST,  # \"real_host\" from .env.remote.local\n'PORT': env.DB_PORT,  # 5432 from .env.remote.local\n}\n}\nAPI_URL = env.API_URL  # \"https://remote.api.com\" from .env.remote\nAPI_TOKEN = env.API_TOKEN  # \"real_token\" from .env.remote.local\n</code></pre> <p>In the next step, we will understand how to commit these new settings.</p>"},{"location":"frameworks/","title":"Using Frameworks","text":"<p>Stela runs at the module level, when you use the <code>from stela import env</code> import. Because that, it will work seamlessly with many python packages and frameworks. Below are the recommendations and best practices for many of them:</p> <p>Please check the folder: /examples</p> <p>It contains working implementations for many frameworks.</p>"},{"location":"frameworks/#popular-framework-examples","title":"Popular Framework Examples","text":""},{"location":"frameworks/#django","title":"Django","text":"<p>The best practice for Django projects is to consume the Stela <code>env</code> object on django <code>settings.py</code> module. This is because many django packages look at this file to consume and define his own settings.</p> <pre><code># Django settings.py\nfrom stela import env\nDEBUG = env.DEBUG\n</code></pre>"},{"location":"frameworks/#pydantic","title":"Pydantic","text":"<p>Pydantic uses the BaseSettings logic to handle environment variables. If you want to use Pydantic Settings with Stela dotenv file combinations (<code>.env</code>, <code>.env.local</code>, etc..) you can use the helper <code>stela_env_settings</code> to replace the original <code>env_settings</code> in your Settings class:</p> <pre><code># .env.local\nFOO__BAR=123\n</code></pre> <pre><code>from pydantic import BaseSettings\nfrom stela.helpers.pydantic import stela_env_settings\nclass FooSettings(BaseSettings):\nbar: str\nclass Settings(BaseSettings):\nfoo: FooSettings\nclass Config:\nenv_nested_delimiter = '__'\nlog_stela_settings = True  # Use to see Stela logs here\n@classmethod\ndef customise_sources(\ncls,\ninit_settings,\nenv_settings,\nfile_secret_settings,\n):\n# Do not include original env_settings here\n# Replace it with stela_env_settings\nreturn (\ninit_settings,\nstela_env_settings,\nfile_secret_settings,\n)\nprint(Settings().foo.bar)\n# &gt; 123\n</code></pre>"},{"location":"frameworks/#fastapi","title":"FastAPI","text":"<p>You can use FastAPI with Stela directly ou via Pydantic Settings (if you use the settings above).</p>"},{"location":"frameworks/#aws-chalice","title":"AWS Chalice","text":"<p>We currently don't support Chalice <code>autoreload</code> in local server. To work around this please use the command <code>chalice local --no-autoreload</code> or import <code>env</code> inside a function.</p>"},{"location":"frameworks/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>The recommended practice is to import Stela data at the first cell, using the <code>%set_env</code> variables to define Stela behavior and then call <code>read_env</code> function to retrieve the Environment Variables:</p> <pre><code># %%\nfrom stela.utils import read_env\n### You can change Stela behavior here\n%set_env\nSTELA_ENV = remote\n%set_env\nSTELA_SHOW_LOGS = False\n### And use the `read_env` helper to reload environment variables\nenv = read_env()\nprint(f\"Current Environment: {env.current_environment}\")\nprint(f\"My Secret: {env.MY_SECRET}\")\n# %%\n</code></pre>"},{"location":"frameworks/#stela-and-asynchronous-code","title":"Stela and Asynchronous Code","text":"<p>If you need to (re)load Stela envs inside an asynchronous method, and you have a complex blocking custom loader, which needs to run inside the loop, you can use the asynchronous <code>aread_env</code> method:</p> <pre><code>from my_project import app\nfrom stela.asyncio import aread_env\n@app.get(\"/\")\nasync def root():\nenv = await aread_env()\nreturn {\n\"message\": \"Hello World\",\n\"environment\": env.current_environment,\n\"secret\": env.MY_SECRET,\n}\n</code></pre> <p>This can be used in any asynchronous frameworks</p> <p>You can use this helper in projects like Django-Ninja, Starlite or Sanic, but only if you have troubles using the default import. Almost all the time the <code>from stela import env</code> import works successfully.</p> <p>For the next step, let's see how to migrate Stela 4.x to Stela 5.0</p>"},{"location":"initialization/","title":"Initializing Stela","text":"<p>For new projects we recommend running the command <code>stela init</code> to create your project settings configuration.</p> <pre><code>stela init\n</code></pre> <p>This command will prompt for the following configurations:</p>"},{"location":"initialization/#environment-variable-name-environment_variable_name","title":"Environment variable name (<code>environment_variable_name</code>)","text":"<p>This is the name of the environment variable that Stela will use to find the current environment. By default, is <code>STELA_ENV</code> but you can change it to whatever you want, like ENV, DJANGO_ENV, etc...</p>"},{"location":"initialization/#default-environment-default_environment","title":"Default environment (<code>default_environment</code>)","text":"<p>If you define a Environment variable name, but not the value for it, Stela can use this optional default environment value. By default, this is disabled and his default value, if enabled, is <code>development</code>.</p>"},{"location":"initialization/#evaluate-dotenv-values-evaluate_data","title":"Evaluate dotenv values (<code>evaluate_data</code>)","text":"<p>If you want to evaluate the values in your dotenv files, you can enable this option. By default, every value from dotenv files are treated as string. If you enable this option, Stela will try to evaluate the values as per ast.literal_eval rules. If the value can't be evaluated, you still receive the string value.</p>"},{"location":"initialization/#show-stela-info-in-logs-show_logs","title":"Show Stela info in logs (<code>show_logs</code>)","text":"<p>If you want to see Stela info in your logs, you can enable this option. By default, this is disabled. Also, if you enable logs, you can filter the values displayed (the default value for this sub-option is enabled) (<code>log_filtered_value</code>).</p>"},{"location":"initialization/#dotenv-overwrites-memory-dotenv_overwrites_memory","title":"Dotenv overwrites memory (<code>dotenv_overwrites_memory</code>)","text":"<p>If you want to overwrite the values in memory with the values from dotenv files, you can enable this option. By default, this is disabled. On standard mode, the values from dotenv files are only used if the value is not already defined in memory.</p>"},{"location":"initialization/#dotenv-file-name-env_file","title":"Dotenv file name (<code>env_file</code>)","text":"<p>If you want to use a different name for your dotenv files, you can change it here. By default, this is <code>.env</code>.</p>"},{"location":"initialization/#stela-project-files","title":"Stela Project Files","text":"<p>Using the information provided, Stela will save their configuration in the <code>.stela</code> file.</p> <p>Tip: You can use your <code>pyproject.toml</code> too.</p> <p>If you use this file, the command will ask if you want to save stela configuration inside toml file.</p> <p>After that, Stela will create the following files if they don't exist:</p> <ul> <li><code>.env</code> (or the name you defined in the previous step)</li> <li><code>.env.local</code></li> <li><code>.env.[environment]</code> (or the name you defined in the previous step if you enabled default environment)</li> <li><code>.env.[environment].local</code></li> <li><code>.gitignore</code></li> </ul>"},{"location":"initialization/#configuration-file-example","title":"Configuration file example:","text":"<p>Using default settings</p> .stelapyproject.tomlshell <pre><code>[stela]\nenvironment_variable_name = STELA_ENV\nevaluate_data = True\nshow_logs = False\ndotenv_overwrites_memory = True\nenv_file = .env\nconfig_file_path = .\n</code></pre> <pre><code>[tool.stela]\nenvironment_variable_name = \"STELA_ENV\"\nevaluate_data = true\nshow_logs = false\ndotenv_overwrites_memory = true\nenv_file = \".env\"\nconfig_file_path = \".\"\n</code></pre> <pre><code>$ export STELA_ENVIRONMENT_VARIABLE_NAME=\"STELA_ENV\"\n$ export STELA_EVALUATE_DATA=true\n$ export STELA_SHOW_LOGS=false\n$ export STELA_DOTENV_OVERWRITES_MEMORY=true\n$ export STELA_ENV_FILE=\".env\"\n$ export STELA_CONFIG_FILE_PATH=\".\"\n</code></pre> <p>See section Settings for the complete Stela options list.</p> <p>In the next step, we will deep dive how Stela uses dotenv files.</p>"},{"location":"quick_setup/","title":"Quick Setup","text":"<p>Let's start with a quick setup: suppose a project add with a <code>.env</code> file with the following content:</p> <pre><code># .env\nAPI_URL=\"http://localhost:8000\"\nDB_URL=\"db://user:password@db:0000/name\"\n</code></pre> <pre><code># settings.py\nfrom stela import env\nAPI_URL = env.API_URL  # http://localhost:8000\nDATABASE_URL_CONNECTION = env.DB_URL  # db://user:password@db:0000/name\n</code></pre> <p>Now, create a <code>.env.local</code> file and add the secret value:</p> <pre><code># .env.local\nDB_URL=\"db://real_user:real_password@real_db:0000/name\"\n</code></pre> <pre><code># settings.py\nfrom stela import env\nAPI_URL = env.API_URL  # http://localhost:8000\nDATABASE_URL_CONNECTION = env.DB_URL  # db://real_user:real_password@real_db:0000/name\n</code></pre> <p>This is because Stela will first load the content from <code>.env</code> file, and then will override the values with the content from <code>.env.local</code> file.</p>"},{"location":"quick_setup/#but-how-about-the-environments","title":"But how about the environments?","text":"<p>Ok, lets add another file: <code>.env.remote</code>:</p> <pre><code># .env.remote\nAPI_URL=\"https://remote.api.com\"\n</code></pre> <p>And we export the <code>STELA_ENV</code> variable:</p> <pre><code>export STELA_ENV=remote\n</code></pre> <p>When we run the python code, we will get the following values:</p> <pre><code>from stela import env\nAPI_URL = env.API_URL  # https://remote.api.com\nDATABASE_URL_CONNECTION = env.DB_URL  # db://real_user:real_password@real_db:0000/name\n</code></pre> <p>And that's it! Now you can use Stela to manage your settings in any python project.</p> <p>Stela is highly customizable, so you can use it in any way you want. It can handle several use cases you can have handling your project settings.</p> <p>For the next pages, lets see each one of these options with more details.</p>"},{"location":"settings/","title":"All Stela Settings options","text":"<p>You can define any of these options as an environment variable, using the <code>STELA_</code> prefix. Some examples:</p> <pre><code>$ export STELA_SHOW_LOGS=true\n$ export STELA_FINAL_LOADER=\"foo.bar\"\n</code></pre> Stela Option Description <code>config_file_path</code> Relative path for dotenv files. Default: <code>.</code> <code>default_environment</code> Default environment value, used if <code>environment_variable_name</code> if not informed. Default: <code>None</code> <code>dotenv_encoding</code> Use this encoding to read dotenv files. Default: <code>utf-8</code> <code>dotenv_overwrites_memory</code> Tells Stela if data from dotenv files overwrite data in memory.  Default: True <code>env_file</code> Stela \"env\" file name. Default: <code>.env</code> <code>env_table</code> The table or section to read data in custom files (toml, ini, etc...). Default: <code>env</code> <code>environment_variable_name</code> Stela environment variable to define project current environment. Default: <code>STELA_ENV</code> <code>evaluate_data</code> Use <code>ast.literal_eval</code> to evaluate variable values. Default: <code>True</code> <code>final_loader</code> Stela Loader function which will be called after read dotenv files. Default: <code>stela.main.loader.default_loader</code> <code>log_filtered_value</code> When logging data, show values filtered. Default: <code>True</code> <code>raise_on_missing_variable</code> Raise error if ask Stela for a unknown variable. Default: <code>True</code> <code>show_logs</code> Stela will use loguru to show logs. Default: <code>False</code> <code>warn_if_env_is_missing</code> Warn if Stela did not find the <code>.env</code> file. Default: <code>False</code> <p>All these options are available in code</p> <p>When you create a custom loader, all options above are available in the <code>options</code> object: <pre><code>def my_custom_loader(options: StelaOptions, env_data: dict) -&gt; dict:\ndotenv_encoding = options.dotenv_encoding\n</code></pre></p>"},{"location":"settings/#stela-deprecated-options","title":"Stela deprecated options","text":"<p>The options below work only for the <code>settings</code> object, not the <code>env</code> object.</p> <p>They are marked as deprecated and will be removed in the next major version:</p> <pre><code># All keys and default values available in pyproject.toml or .stela\n# Works only for the settings object - from stela import settings\nconfig_file_extension = \"INI\"                       # or YAML, TOML, JSON\nconfig_file_prefix = \"\"                             # You can add a prefix before name - ex.: env_development.ini\nconfig_file_suffix = \"\"                             # You can add a suffix after name - ex.: development_v1.ini\ndo_not_read_environment = false                     # Do not read environment variables from shell\ndo_not_read_dotenv = false                          # Do not read dotenv file\nenvironment_prefix = \"\"                             # ex.: settings[\"foo.bar\"] looks for MY_PREFIX_FOO_BAR\nenvironment_suffix = \"\"                             # ex.: settings[\"foo.bar\"] looks for FOO_BAR_MY_SUFFIX\nuse_environment_layers = false                      # Use environment layers\n</code></pre>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>django-google-sso: Easily add Google Authentication in your Django projects.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-questions","title":"Common questions:","text":"How can I use [...] with Stela? <p>The use cases in Using Frameworks above give a good hint about how to use Stela with several python projects. If you have a question which this guideline didn't resolve, please open an issue.</p>"},{"location":"troubleshooting/#example-apps","title":"Example Apps","text":"<p>To see how this library works check the <code>Example Folder</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"update/","title":"Migrating from older versions","text":"<p>Stela 5.x is a major rework from previous versions. Use this guideline to how to update your code and your settings to the new format:</p>"},{"location":"update/#tldr","title":"TLDR;","text":"<ol> <li>Run <code>stela init</code>. When ask for convert old format, click \"Yes\". You can also run <code>stela convert</code> to run the    conversion only.</li> <li>Move all logic from <code>conf_stela.py</code> (if exists) to a single custom loader function (see Using Loader).</li> <li>Add the stela option <code>final_loader</code> for your custom loader in your Stela configuration.</li> </ol> <p>Use the automatic conversion logic</p> <p>For large projects, it betters to automate the conversion and just review the result. Before any modification, the script will back up your files. On errors, you can revert automatic conversion typing <code>stela convert --revert</code></p>"},{"location":"update/#manual-update","title":"Manual Update","text":"<p>For the previous versions, project configuration was to read data from an external file (like <code>pyproject.toml</code>) and save it to Stela <code>settings</code> dictionary:</p> <pre><code># pyproject.toml\n[tool.stela]\nuse_environment_layers = true\ndefault_environment = \"development\"\n[environment]\nproject.secret = 1\n[environment.development]\nproject.secret = 2\n</code></pre> <pre><code># Stela 4.x\nfrom stela import settings\nsecret = settings[\"project.secret\"]\n#&gt; 2\n</code></pre> <p>The \"dotenv\" logic was to load the <code>.env</code> in memory and check if the SCREAMING_SNAKE_CASE version of the <code>settings</code> key exists, before returning the value from configuration files:</p> <pre><code># original .env\nPROJECT_SECRET=3\n</code></pre> <pre><code># Stela 4.x\nfrom stela import settings\nsecret = settings[\"project.secret\"]  # Will look for PROJECT_SECRET variable first\n#&gt; 3\n</code></pre>"},{"location":"update/#converting-old-data-format","title":"Converting old data format","text":"<p>To convert old format data you can replace <code>settings</code> for <code>env</code> in your imports and replace the settings key, for the attribute equal to the variable inside the <code>.env</code> files:</p> <pre><code># Stela 5.x\nfrom stela import env  # from stela import settings\nsecret = env.PROJECT_SECRET  # secret = settings[\"project.secret\"]\n#&gt; 3\n</code></pre>"},{"location":"update/#update-your-configuration-files","title":"Update your configuration files","text":"<p>Rename your existing <code>.env</code> to <code>.env.local</code> and move the data from your configuration files for the corresponding <code>.env.*</code> file and your secrets to the corresponding <code>.env.*.local</code> file. Using the above example:</p> <pre><code># original .env\nPROJECT_DEBUG=3\n</code></pre> <pre><code># pyproject.toml\n[tool.stela]\nuse_environment_layers = true\ndefault_environment = \"development\"\n[environment]\nproject.secret = 1\n[environment.development]\nproject.secret = 2\n</code></pre> <p>Turns to:</p> <pre><code># .env.local renamed from .env\nPROJECT_SECRET=3\n</code></pre> <pre><code># .env\nPROJECT_SECRET=1\n</code></pre> <pre><code># .env.development\nPROJECT_SECRET=2\n</code></pre>"},{"location":"update/#the-conf_stelapy-file","title":"The <code>conf_stela.py</code> file","text":"<p>This file is deprecated too. Please move all logic to your custom loader (see example below).</p>"},{"location":"update/#option-using-stela-4x-behavior-to-load-data","title":"Option: Using Stela 4.x behavior to load data","text":"<p>You can also still use the 4.x behavior, creating a custom final loader which mimics the original logic. The example below is for a Stela 4.x configured to using <code>pyproject.toml</code> for store settings and using the <code>conf_stela.py</code> file for custom logic:</p> <pre><code>import toml\nfrom stela.config import StelaOptions\nfrom stela.utils import merge_dicts, flatten_dict\nfrom typing import Any\ndef legacy_pyproject_loader(\noptions: StelaOptions,\nenv_data: dict[str, Any]\n) -&gt; dict[str, Any]:\n\"\"\"Custom loader for Stela 4.x behavior.\n    Add this function on Stela configuration using the\n    `final_loader` option.\n    Please remember to update your code as soon as possible.\n    Using stela as a dictionary is deprecated and\n    will be removed at next major release.\n    Data returned by this function will use read data in the same way\n    as Stela 4.x, but the data must be retrieved using Stela 5.x syntax.\n    Toml::\n        [environment]\n        foo = \"bar\"\n        [environment.development]\n        foo = \"baz\"\n    Code::\n        from stela import env\n        secret = env.PROJECT_SECRET\n    \"\"\"\nfrom stela.loaders.cut import StelaCutLoader  #  will be removed in Stela 6.0\nfrom stela.utils import merge_env\nfilepath = \"pyproject.toml\"\n# Read toml data\ntoml_data = toml.load(filepath)\n# Get Global Environment\nglobal_env = toml_data.get(options.env_table, {})\n# Get Current Environment Environment\ncurrent_env = global_env.get(options.current_environment, {})\n# Merge Current Environment data into Global data\nmerge_dicts(current_env, global_env)\n# If you are using the stela_conf.py,\n# The logic will run here\nold_loader = StelaCutLoader()\nif old_loader.pre_load_function:\nglobal_env.update(old_loader.pre_load_function())\nif old_loader.custom_load_function:\nglobal_env.update(old_loader.custom_load_function())\nif old_loader.custom_load_function:\nglobal_env.update(old_loader.post_load_function())\n# Finally, we override global_env with data from dotenv files:\nproject_settings = merge_env(global_env, env_data)\nreturn project_settings\n</code></pre> <p>Now, add this <code>legacy_pyproject_loader</code> in your <code>pyproject.toml</code> stela configuration:</p> pyproject.toml <pre><code>[tool.stela]\n...\nfinal_loader = \"path.to.legacy_pyproject_loader\"\n</code></pre> <p>Please update your code</p> <p>We strongly suggest moving Stela to the new format. Using Stela as a dictionary is deprecated and will be removed on the next major version, and we will drop support for use Stela as a dict.</p> <p>For the next step, let's look for all Stela Configuration Options</p>"},{"location":"usage/","title":"Using Stela","text":"<p>Stela usage is very simple. Just import the <code>env</code> object:</p> <pre><code>from stela import env\nMY_VAR = env.MY_VAR\n</code></pre> <p>If you want to get the environment variable programmatically, use the <code>get</code> function:</p> <pre><code>from stela import env\nvar = \"MY_VAR\"\nenv = env.get(var)\n</code></pre> <p>If the variable did not exist, Stela will raise a <code>StelaValueError</code>. You can change this using the <code>raise_on_missing</code> parameter. You can also add a default value if you want, using the <code>default</code> parameter too:</p> <pre><code>from stela import env\nvar = \"MY_VAR\"\nenv = env.get(var, raise_on_missing=False, default=\"foo\")\n</code></pre> <p>You can also list all environment variables:</p> <pre><code>from stela import env\nall_vars = env.list()\n#&gt; [\"MY_VAR\"]\n</code></pre> <p>And you can use the <code>env</code> object to get information about the current environment:</p> <pre><code>from stela import env\nENV = env.current_environment\nDEFAULT_ENV = env.default_environment\n</code></pre>"},{"location":"usage/#when-stela-read-the-data","title":"When Stela read the data?","text":"<p>Stela is imported once at module level - project settings are load and immediately available:</p> <pre><code>from stela import env\nfrom flask import Flask\napp = Flask(__name__)\napp.config.update(\nSECRET_KEY=env.FLASK_SECRET\n)\n@app.route(\"/\")\ndef hello():\nreturn f\"Hello, Environment is {env.current_environment}\"\n</code></pre>"},{"location":"usage/#refreshing-stela-settings","title":"Refreshing Stela settings","text":"<p>If you need to reload settings, use the <code>stela.utils.read_env</code> function:</p> <pre><code>from stela.utils import read_env\ndef reload_app():\nenv = read_env()\n</code></pre>"},{"location":"usage/#logging-data","title":"Logging data","text":"<p>Stela use the loguru package for logging, using <code>INFO</code> for general messages and <code>DEBUG</code> for key/values retrieved in toml, environment keys, decorators, etc... You can use the logs to debug data during Stela operation.</p> <p>By default, the log is disabled. You can modify this behavior globally with the following configurations:</p> .stelapyproject.tomlshell <pre><code>[stela]\nshow_logs = true\nlog_filtered_value = true\n</code></pre> <pre><code>[tool.stela]\nshow_logs = true\nlog_filtered_value = true\n</code></pre> <pre><code>$ export STELA_SHOW_LOGS=true\n$ export STELA_LOG_FILTERED_VALUE=true\n</code></pre> <p>Also, you can use decorators for fine-tuning logging per function:</p> <pre><code>from stela import env\nfrom stela.decorators import stela_enable_logs, stela_disable_logs\n@stela_enable_logs\ndef my_bugged_code():\nreturn env.MY_API_URL\n@stela_disable_logs\ndef my_sensible_code():\nreturn env.MY_SECRET_KEY\n</code></pre> <p>The log level can be defined using the <code>LOGURU_LOG_LEVEL</code> as per loguru documentation.</p> <p>For the next step, we will look at how IDEs can autocomplete Stela environment variables.</p>"},{"location":"using_loader/","title":"Using loader","text":""},{"location":"using_loader/#the-stela-final-loader","title":"The Stela Final Loader","text":"<p>Stela Final Loader is a function which receives two arguments:</p> <ul> <li>The Stela Options object: <code>options</code></li> <li>The dictionary content the data from dotenvs read based on current stela options: <code>env_data</code></li> </ul> <p>And it's the last code called for before returning the <code>env</code> object.</p>"},{"location":"using_loader/#default-stela-final-loader-code","title":"Default Stela Final Loader code","text":"<p>Default behavior is just return data parsed from Env files:</p> <pre><code>from stela.config import StelaOptions\ndef default_loader(\noptions: StelaOptions,\nenv_data: dict[str, any]\n) -&gt; dict[str, any]:\n\"\"\"Stela Default Loader.\n    Default Action is just return the env_data received.\n    :param options: Stela Options\n    :param env_data: Dict with environment data\n    :return: Dict\n    \"\"\"\nfrom loguru import logger\nlogger.info(\nf\"Using Stela Default Loader. \"\nf\"Current environment is: {options.current_environment}\"\n)\nreturn env_data\n</code></pre>"},{"location":"using_loader/#the-stela-options-object","title":"The Stela Options object","text":"<p>All stela options are attributes in this object. Please check Settings for the complete list.</p>"},{"location":"using_loader/#creating-your-custom-final-loader","title":"Creating your custom Final Loader","text":"<p>If you need to get your Environment variables from other sources than dotenv files, or need to mix data, you can use your own logic for the Loader. Just inform Stela which function needs to be called:</p> .stelapyproject.tomlshell <pre><code>[stela]\nfinal_loader = \"path.to.my.custom_loader\"\n...\n</code></pre> <pre><code>[tool.stela]\nfinal_loader=\"path.to.my.custom_loader\"\n...\n</code></pre> <pre><code>$ export STELA_FINAL_LOADER=\"path.to.my.custom_loader\"\n</code></pre> <p>This function will be called, and need to receive the two parameters above: <code>options</code> and <code>env_data</code> and it must return a valid python dictionary.</p>"},{"location":"using_loader/#examples","title":"Examples","text":""},{"location":"using_loader/#read-data-from-toml-file","title":"Read data from toml file","text":"<pre><code>import toml\nfrom typing import Any\nfrom stela.config import StelaOptions\nfrom stela.utils import merge_env\ndef pyproject_loader(options: StelaOptions, env_data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Load settings from pyproject.toml to current Stela data.\n    Data returned must be a Python Dictionary.\n    :param env_data: Data parsed from dotenv files\n    :param options: Stela Options obj\n    :return Dict[str, Any]\n    \"\"\"\nfilepath = \"pyproject.toml\"\nsub_table = \"environment\"  # The sub table inside toml which holds your settings\n# Read toml data for the sub table\ntoml_data = toml.load(filepath)\nsub_table_data = toml_data.get(sub_table, {})\n# Update toml data with dotenv info\n# The sub_table_data are the \"default\" settings.\n# The env_data are the final ones.\nproject_settings = merge_env(sub_table_data, env_data)\nreturn project_settings\n</code></pre>"},{"location":"using_loader/#read-data-from-aws-system-manager-parameter-store","title":"Read data from AWS System Manager Parameter Store","text":"<pre><code>import boto3\nfrom typing import Any\nfrom stela.config import StelaOptions\ndef ssm_loader(options: StelaOptions, env_data: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"Load settings from AWS Parameter Store (SSM) to current Stela data.\n    Data returned must be a Python Dictionary.\n    :param env_data: Data parsed from dotenv file\n    :param options: Stela Options obj\n    :return Dict[str, Any]\n    \"\"\"\nssm = boto3.client('ssm')\nenvironment = options.current_environment\n# Get from SSM\nresponse = ssm.get_parameters_by_path(\nPath=f'/my-project/{environment}',\nWithDecryption=True\n)\nssm_data = {parameter[\"Name\"].upper(): parameter[\"Value\"] for parameter in response[\"Parameters\"]}\n# Overwrite env_data with SSM data\n# Normally information on remote sources\n# like vaults, are the final ones\nenv_data.update(ssm_data)\nreturn env_data\n</code></pre> <p>The goal here is: One Interface, Any Sources</p> <p>You can use any source or logic to load your environment variables. They can have the complexity you need for the project you're working. But the interface to work with these values is always the same.</p>"},{"location":"using_loader/#different-loaders-per-environment","title":"Different Loaders per Environment","text":"<p>If you need different custom loaders per environment, you can use Stela Environment variables to do this:</p> <pre><code># Development\n$ export STELA_FINAL_LOADER=\"path.to.dev_loader\"\n</code></pre> <pre><code># Production\n$ export STELA_FINAL_LOADER=\"path.to.prod_loader\"\n</code></pre> <p>For the next step, let's review how to integrate Stela with many popular Python packages and Frameworks.</p>"}]}